# Результаты бенчмарков

## Таблица среднего времени работы алгоритмов для 3 случаеев (случайных масивов) с разной длинной. Время - *ms*.

| Algorithm / dataLength | 100 | 1000 | 10000 | 100000 | 1000000 |
|-|-|-|-|-|-|
| HeapSort | 0.004 | 0.064 | 0.989 | 16.084 | 312.126 |
| InsertionSort | 0.003 | 0.083 | 15.049 | 2396.652 | 328196.852 |
| ImprovedInsertionSort | 0.004 | 0.063 | 2.049 | 168.551 | 18276.827 |
| MergeSort | 0.006 | 0.080 | 1.044 | 13.551 | 216.753 |
| QuickSort | 0.004 | 0.056 | 0.869 | 10.967 | 167.526 |

## Таблица погрешностей. Время - *ms*.

| Algorithm / dataLength | 100 | 1000 | 10000 | 100000 | 1000000 |
|-|-|-|-|-|-|
| HeapSort | 0.001 | 0.001 | 0.138 | 0.183 | 364.407 |
| InsertionSort | 0.001 | 0.009 | 0.680 | 347.898 | 123781.439 |
| ImprovedInsertionSort | 0.001 | 0.002 | 0.087 | 17.776 | 3247.797 |
| MergeSort | 0.001 | 0.002 | 0.016 | 0.074 | 34.248 |
| QuickSort | 0.001 | 0.001 | 1.167 | 0.153 | 23.741 |

## Выводы

* `InsertionSort` показал себя лучше всех на массиве размера *100* при одинаковых погрешностях для других алгоритмов. На *1000* время все еще сравнимо с остальными алгоритмами хотя явно немнго больше. Дальше его смысла рассматривать нет т.к. время очевидно значительно увеличивается и уступает всем остальным алгоритмам.
* `ImprovedInsertionSort` работает заметно быстрее. Теперь на *10000* время его работы сопоставимо с остальными (*кроме `InsertionSort`*). Дальше его рассматривать смысла нет.
* `HeapSort` на больших значения очевидно лучше `InsertionSort` и `ImprovedInsertionSort` однако заметно проигрывает `QuickSort` и `MergeSort`. Нестабилное время работы очень большая погрешность для *1000000*.
* `QuickSort` и `MergeSort` имеют более стабильные значения погрешностей. Время их работы для всех размеров сопоставимо, однако `QuickSort` немного быстрее.

## Итог

`QuickSort` и `MergeSort` имеют схожее время работы для всех случаеев, при этом работают быстрее всех остальных алгоритмов. Но они уступают `InsertionSort` на размере *100* (*маленьких массивах*).
