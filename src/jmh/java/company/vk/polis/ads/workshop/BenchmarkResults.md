# Результаты бенчмарков

## Таблица среднего времени работы алгоритмов для 3 случаеев (случайных масивов) с разной длинной. Время - *ms*.

| Algorithm / dataLength | 100 | 1000 | 10000 | 100000 | 1000000 |
|-|-|-|-|-|-|
| HeapSort | 0.004 | 0.064 | 0.989 | 16.084 | 312.126 |
| InsertionSort | 0.003 | 0.083 | 15.049 | 2396.652 | 328196.852 |
| ImprovedInsertionSort | 0.004 | 0.063 | 2.049 | 168.551 | 18276.827 |
| MergeSort | 0.006 | 0.080 | 1.044 | 13.551 | 216.753 |
| QuickSort | 0.004 | 0.056 | 0.869 | 10.967 | 167.526 |

## Таблица погрешностей. Время - *ms*.

| Algorithm / dataLength | 100 | 1000 | 10000 | 100000 | 1000000 |
|-|-|-|-|-|-|
| HeapSort | 0.001 | 0.001 | 0.138 | 0.183 | 364.407 |
| InsertionSort | 0.001 | 0.009 | 0.680 | 347.898 | 123781.439 |
| ImprovedInsertionSort | 0.001 | 0.002 | 0.087 | 17.776 | 3247.797 |
| MergeSort | 0.001 | 0.002 | 0.016 | 0.074 | 34.248 |
| QuickSort | 0.001 | 0.001 | 1.167 | 0.153 | 23.741 |

## Выводы

* `InsertionSort` показал себя лучше всех на массиве размера *100* при одинаковых погрешностях для других алгоритмов. Начиная с *1000* время все еще сравнимо с остальными алгоритмами хотя явно немнго больше. Дальше его смысла рассматривать нет т.к. время очевидно значительно увеличивается и уступает все остальным алгоритмам.
* 
